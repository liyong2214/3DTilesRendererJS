import{k as l,i as R,as as W,j,d as K,an as Q,bb as tt}from"./three.module-DpclfMcJ.js";const d=new W,U=new l,et={};function it(r){const{x:t,y:e,z:i}=r;r.x=i,r.y=t,r.z=e}function ot(r){return-(r-Math.PI/2)}function B(r){return-r+Math.PI/2}function st(r,t,e={}){return d.theta=t,d.phi=B(r),U.setFromSpherical(d),d.setFromVector3(U),e.lat=ot(d.phi),e.lon=d.theta,e}function b(r,t="E",e="W"){const i=r<0?e:t;r=Math.abs(r);const o=~~r,s=(r-o)*60,n=~~s,y=~~((s-n)*60);return`${o}° ${n}' ${y}" ${i}`}function lt(r,t,e=!1){const i=st(r,t,et);let o,s;return e?(o=`${(R.RAD2DEG*i.lat).toFixed(4)}°`,s=`${(R.RAD2DEG*i.lon).toFixed(4)}°`):(o=b(R.RAD2DEG*i.lat,"N","S"),s=b(R.RAD2DEG*i.lon,"E","W")),`${o} ${s}`}const X=new W,m=new l,c=new l,w=new l,nt=new l,p=new j,u=new j,A=new K,a=new tt,Y=new l,Z=new l,T=new l,D=new l,G=new Q,rt=1e-12,at=.1,V=0,L=1,O=2;class ut{constructor(t=1,e=1,i=1){this.radius=new l(t,e,i)}intersectRay(t,e){return p.makeScale(...this.radius).invert(),A.center.set(0,0,0),A.radius=1,G.copy(t).applyMatrix4(p),G.intersectSphere(A,e)?(p.makeScale(...this.radius),e.applyMatrix4(p),e):null}getEastNorthUpFrame(t,e,i){return this.getEastNorthUpAxes(t,e,Y,Z,T,D),i.makeBasis(Y,Z,T).setPosition(D)}getEastNorthUpAxes(t,e,i,o,s,n=D){this.getCartographicToPosition(t,e,0,n),this.getCartographicToNormal(t,e,s),i.set(-n.y,n.x,0).normalize(),o.crossVectors(s,i).normalize()}getNorthernTangent(t,e,i,o=nt){return console.log("Ellipsoid: getNorthernTangent has been deprecated. Use getEastNorthUpAxes instead."),this.getEastNorthUpAxes(t,e,o,i,T),o.multiplyScalar(-1),i}getAzElRollFromRotationMatrix(t,e,i,o,s=V){return s===L?(a.set(-Math.PI/2,0,0,"XYZ"),u.makeRotationFromEuler(a).premultiply(i)):s===O?(a.set(-Math.PI/2,0,Math.PI,"XYZ"),u.makeRotationFromEuler(a).premultiply(i)):u.copy(i),this.getEastNorthUpFrame(t,e,p).invert(),u.premultiply(p),a.setFromRotationMatrix(u,"ZXY"),o.azimuth=-a.z,o.elevation=a.x,o.roll=a.y,o}getRotationMatrixFromAzElRoll(t,e,i,o,s,n,h=V){return this.getEastNorthUpFrame(t,e,p),a.set(o,s,-i,"ZXY"),n.makeRotationFromEuler(a).premultiply(p).setPosition(0,0,0),h===L?(a.set(Math.PI/2,0,0,"XYZ"),u.makeRotationFromEuler(a),n.multiply(u)):h===O&&(a.set(-Math.PI/2,0,Math.PI,"XYZ"),u.makeRotationFromEuler(a),n.multiply(u)),n}getCartographicToPosition(t,e,i,o){this.getCartographicToNormal(t,e,m);const s=this.radius;c.copy(m),c.x*=s.x**2,c.y*=s.y**2,c.z*=s.z**2;const n=Math.sqrt(m.dot(c));return c.divideScalar(n),o.copy(c).addScaledVector(m,i)}getPositionToCartographic(t,e){this.getPositionToSurfacePoint(t,c),this.getPositionToNormal(t,m);const i=w.subVectors(t,c);return e.lon=Math.atan2(m.y,m.x),e.lat=Math.asin(m.z),e.height=Math.sign(i.dot(t))*i.length(),e}getCartographicToNormal(t,e,i){return X.set(1,B(t),e),i.setFromSpherical(X).normalize(),it(i),i}getPositionToNormal(t,e){const i=this.radius;return e.copy(t),e.x/=i.x**2,e.y/=i.y**2,e.z/=i.z**2,e.normalize(),e}getPositionToSurfacePoint(t,e){const i=this.radius,o=1/i.x**2,s=1/i.y**2,n=1/i.z**2,h=t.x*t.x*o,y=t.y*t.y*s,z=t.z*t.z*n,v=h+y+z,f=Math.sqrt(1/v),S=c.copy(t).multiplyScalar(f);if(v<at)return isFinite(f)?e.copy(S):null;const H=w.set(S.x*o*2,S.y*s*2,S.z*n*2);let P=(1-f)*t.length()/(.5*H.length()),C=0,g,q,M,E,x,F,N,_,$,k,I;do{P-=C,M=1/(1+P*o),E=1/(1+P*s),x=1/(1+P*n),F=M*M,N=E*E,_=x*x,$=F*M,k=N*E,I=_*x,g=h*F+y*N+z*_-1,q=h*$*o+y*k*s+z*I*n;const J=-2*q;C=g/J}while(Math.abs(g)>rt);return e.set(t.x*M,t.y*E,t.z*x)}calculateHorizonDistance(t,e){const i=this.calculateEffectiveRadius(t);return Math.sqrt(2*i*e+e**2)}calculateEffectiveRadius(t){const e=this.radius.x,o=1-this.radius.z**2/e**2,s=t*R.DEG2RAD,n=Math.sin(s)**2;return e/Math.sqrt(1-o*n)}getPositionElevation(t){this.getPositionToSurfacePoint(t,c);const e=w.subVectors(t,c);return Math.sign(e.dot(t))*e.length()}copy(t){return this.radius.copy(t.radius),this}clone(){return new this.constructor().copy(this)}}export{L as C,ut as E,O,lt as t};
