import{k as g,O as y,aD as M,a as v,s as x,i as h}from"./three.module-DpclfMcJ.js";const e=new g,s=new g,d=new y,P=new g;class T extends M{get animating(){return this._alpha!==0&&this._alpha!==1}get camera(){return this._alpha===0?this.perspectiveCamera:this._alpha===1?this.orthographicCamera:this.transitionCamera}get mode(){return this._target===0?"perspective":"orthographic"}set mode(o){if(o===this.mode)return;const a=this.camera;o==="perspective"?(this._target=0,this._alpha=0):(this._target=1,this._alpha=1),this.dispatchEvent({type:"camera-change",camera:this.camera,prevCamera:a})}constructor(o=new v,a=new y){super(),this.perspectiveCamera=o,this.orthographicCamera=a,this.transitionCamera=new v,this.orthographicPositionalZoom=!0,this.orthographicOffset=50,this.fixedPoint=new g,this.duration=200,this.autoSync=!0,this._target=0,this._alpha=0,this._clock=new x}toggle(){this._target=this._target===1?0:1}update(){this.autoSync&&this.syncCameras();const{perspectiveCamera:o,orthographicCamera:a,transitionCamera:t,camera:p}=this,m=this._clock.getDelta()*1e3;if(this._alpha!==this._target){const n=Math.sign(this._target-this._alpha)*m/this.duration;this._alpha=h.clamp(this._alpha+n,0,1),this.dispatchEvent({type:"change"})}const c=p;let i=null;this._alpha===0?i=o:this._alpha===1?i=a:(i=t,this._updateTransitionCamera()),c!==i&&(i===t&&this.dispatchEvent({type:"transition-start"}),this.dispatchEvent({type:"camera-change",camera:i,prevCamera:c}),c===t&&this.dispatchEvent({type:"transition-end"}))}syncCameras(){const o=this._getFromCamera(),{perspectiveCamera:a,orthographicCamera:t,transitionCamera:p,fixedPoint:r}=this;if(e.set(0,0,-1).transformDirection(o.matrixWorld).normalize(),o.isPerspectiveCamera){if(this.orthographicPositionalZoom)t.position.copy(a.position).addScaledVector(e,-this.orthographicOffset),t.rotation.copy(a.rotation),t.updateMatrixWorld();else{const l=s.subVectors(r,t.position).dot(e),n=s.subVectors(r,a.position).dot(e);s.copy(a.position).addScaledVector(e,n),t.rotation.copy(a.rotation),t.position.copy(s).addScaledVector(e,-l),t.updateMatrixWorld()}const m=Math.abs(s.subVectors(a.position,r).dot(e)),c=2*Math.tan(h.DEG2RAD*a.fov*.5)*m,i=t.top-t.bottom;t.zoom=i/c,t.updateProjectionMatrix()}else{const m=Math.abs(s.subVectors(t.position,r).dot(e)),i=(t.top-t.bottom)/t.zoom*.5/Math.tan(h.DEG2RAD*a.fov*.5);a.rotation.copy(t.rotation),a.position.copy(t.position).addScaledVector(e,m).addScaledVector(e,-i),a.updateMatrixWorld(),this.orthographicPositionalZoom&&(t.position.copy(a.position).addScaledVector(e,-this.orthographicOffset),t.updateMatrixWorld())}p.position.copy(a.position),p.rotation.copy(a.rotation)}_getTransitionDirection(){return Math.sign(this._target-this._alpha)}_getToCamera(){const o=this._getTransitionDirection();return o===0?this._target===0?this.perspectiveCamera:this.orthographicCamera:o>0?this.orthographicCamera:this.perspectiveCamera}_getFromCamera(){const o=this._getTransitionDirection();return o===0?this._target===0?this.perspectiveCamera:this.orthographicCamera:o>0?this.perspectiveCamera:this.orthographicCamera}_updateTransitionCamera(){const{perspectiveCamera:o,orthographicCamera:a,transitionCamera:t,fixedPoint:p}=this,r=this._alpha;e.set(0,0,-1).transformDirection(a.matrixWorld).normalize(),d.copy(a),d.position.addScaledVector(e,a.near),a.far-=a.near,a.near=0,e.set(0,0,-1).transformDirection(o.matrixWorld).normalize();const m=Math.abs(s.subVectors(o.position,p).dot(e)),c=2*Math.tan(h.DEG2RAD*o.fov*.5)*m,i=h.lerp(o.fov,1,r),l=c*.5/Math.tan(h.DEG2RAD*i*.5),n=P.lerpVectors(o.position,d.position,r);n.addScaledVector(e,Math.abs(s.subVectors(n,p).dot(e))-l);const C=s.subVectors(o.position,n).dot(e),f=s.subVectors(d.position,n).dot(e),u=h.lerp(C+o.near,f+d.near,r),_=h.lerp(C+o.far,f+d.far,r),D=Math.max(_,0)-Math.max(u,0);t.aspect=o.aspect,t.fov=i,t.near=Math.max(u,D*1e-5),t.far=_,t.position.copy(n),t.rotation.copy(o.rotation),t.updateProjectionMatrix(),t.updateMatrixWorld()}}export{T as C};
