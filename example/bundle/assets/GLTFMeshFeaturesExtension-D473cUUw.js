import{j as le,aI as fe,r as se,k as he,V as T,W as ye,aE as G,b as pe,aJ as de,aK as me,aL as Ae,p as ne,aM as Te,F as xe}from"./three.module-DpclfMcJ.js";import{F as we}from"./Pass-inUSP30K.js";class B{constructor(e,s,t,n){B.prototype.isMatrix2=!0,this.elements=[1,0,0,1],e!==void 0&&this.set(e,s,t,n)}identity(){return this.set(1,0,0,1),this}fromArray(e,s=0){for(let t=0;t<4;t++)this.elements[t]=e[t+s];return this}set(e,s,t,n){const r=this.elements;return r[0]=e,r[1]=t,r[2]=s,r[3]=n,this}}function m(i,e,s){return i&&e in i?i[e]:s}function re(i){return i!=="BOOLEAN"&&i!=="STRING"&&i!=="ENUM"}function Ee(i){return/^FLOAT/.test(i)}function C(i){return/^VEC/.test(i)}function _(i){return/^MATRIX/.test(i)}function ie(i,e,s,t=null){return _(s)||C(s)?t.fromArray(i,e):i[e]}function L(i){const{type:e,componentType:s}=i;switch(e){case"SCALAR":return s==="INT64"?0n:0;case"VEC2":return new T;case"VEC3":return new he;case"VEC4":return new se;case"MAT2":return new B;case"MAT3":return new fe;case"MAT4":return new le;case"BOOLEAN":return!1;case"STRING":return"";case"ENUM":return 0}}function v(i,e){if(e==null)return!1;switch(i){case"SCALAR":return typeof e=="number"||typeof e=="bigint";case"VEC2":return e.isVector2;case"VEC3":return e.isVector3;case"VEC4":return e.isVector4;case"MAT2":return e.isMatrix2;case"MAT3":return e.isMatrix3;case"MAT4":return e.isMatrix4;case"BOOLEAN":return typeof e=="boolean";case"STRING":return typeof e=="string";case"ENUM":return typeof e=="number"||typeof e=="bigint"}throw new Error("ClassProperty: invalid type.")}function V(i,e=null){switch(i){case"INT8":return Int8Array;case"INT16":return Int16Array;case"INT32":return Int32Array;case"INT64":return BigInt64Array;case"UINT8":return Uint8Array;case"UINT16":return Uint16Array;case"UINT32":return Uint32Array;case"UINT64":return BigUint64Array;case"FLOAT32":return Float32Array;case"FLOAT64":return Float64Array}switch(e){case"BOOLEAN":return Uint8Array;case"STRING":return Uint8Array}throw new Error("ClassProperty: invalid type.")}function Ie(i,e=null){if(i.array){e=e&&Array.isArray(e)?e:[],e.length=i.count;for(let t=0,n=e.length;t<n;t++)e[t]=M(i,e[t])}else e=M(i,e);return e}function M(i,e=null){const s=i.default,t=i.type;if(e=e||L(i),s===null){switch(t){case"SCALAR":return 0;case"VEC2":return e.set(0,0);case"VEC3":return e.set(0,0,0);case"VEC4":return e.set(0,0,0,0);case"MAT2":return e.identity();case"MAT3":return e.identity();case"MAT4":return e.identity();case"BOOLEAN":return!1;case"STRING":return"";case"ENUM":return""}throw new Error("ClassProperty: invalid type.")}else if(_(t))e.fromArray(s);else if(C(t))e.fromArray(s);else return s}function be(i,e){if(i.noData===null)return e;const s=i.noData,t=i.type;if(Array.isArray(e))for(let o=0,a=e.length;o<a;o++)e[o]=n(e[o]);else e=n(e);return e;function n(o){return r(o)&&(o=M(i,o)),o}function r(o){if(_(t)){const a=o.elements;for(let u=0,f=s.length;u<f;u++)if(s[u]!==a[u])return!1;return!0}else if(C(t)){for(let a=0,u=s.length;a<u;a++)if(s[a]!==o.getComponent(a))return!1;return!0}else return s===o}}function Ne(i,e){switch(i){case"INT8":return Math.max(e/127,-1);case"INT16":return Math.max(e,32767,-1);case"INT32":return Math.max(e/2147483647,-1);case"INT64":return Math.max(Number(e)/9223372036854776e3,-1);case"UINT8":return e/255;case"UINT16":return e/65535;case"UINT32":return e/4294967295;case"UINT64":return Number(e)/18446744073709552e3}}function Oe(i,e){const{type:s,componentType:t,scale:n,offset:r,normalized:o}=i;if(Array.isArray(e))for(let c=0,l=e.length;c<l;c++)e[c]=a(e[c]);else e=a(e);return e;function a(c){return _(s)?c=f(c):C(s)?c=u(c):c=p(c),c}function u(c){return c.x=p(c.x),c.y=p(c.y),"z"in c&&(c.z=p(c.z)),"w"in c&&(c.w=p(c.w)),c}function f(c){const l=c.elements;for(let y=0,d=l.length;y<d;y++)l[y]=p(l[y]);return c}function p(c){return o&&(c=Ne(t,c)),(o||Ee(t))&&(c=c*n+r),c}}function j(i,e,s=null){if(i.array){Array.isArray(e)||(e=new Array(i.count||0)),e.length=s!==null?s:i.count;for(let t=0,n=e.length;t<n;t++)v(i.type,e[t])||(e[t]=L(i))}else v(i.type,e)||(e=L(i));return e}function P(i,e){for(const s in e)s in i||delete e[s];for(const s in i){const t=i[s];e[s]=j(t,e[s])}}function Se(i){switch(i){case"ENUM":return 1;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":return 4;case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;case"BOOLEAN":return-1;case"STRING":return-1;default:return-1}}class D{constructor(e,s,t=null){this.name=s.name||null,this.description=s.description||null,this.type=s.type,this.componentType=s.componentType||null,this.enumType=s.enumType||null,this.array=s.array||!1,this.count=s.count||0,this.normalized=s.normalized||!1,this.offset=s.offset||0,this.scale=m(s,"scale",1),this.max=m(s,"max",1/0),this.min=m(s,"min",-1/0),this.required=s.required||!1,this.noData=m(s,"noData",null),this.default=m(s,"default",null),this.semantic=m(s,"semantic",null),this.enumSet=null,this.accessorProperty=t,t&&(this.offset=m(t,"offset",this.offset),this.scale=m(t,"scale",this.scale),this.max=m(t,"max",this.max),this.min=m(t,"min",this.min)),s.type==="ENUM"&&(this.enumSet=e[this.enumType],this.componentType===null&&(this.componentType=m(this.enumSet,"valueType","UINT16")))}shapeToProperty(e,s=null){return j(this,e,s)}resolveDefaultElement(e){return M(this,e)}resolveDefault(e){return Ie(this,e)}resolveNoData(e){return be(this,e)}resolveEnumsToStrings(e){const s=this.enumSet;if(this.type==="ENUM")if(Array.isArray(e))for(let n=0,r=e.length;n<r;n++)e[n]=t(e[n]);else e=t(e);return e;function t(n){const r=s.values.find(o=>o.value===n);return r===null?"":r.name}}adjustValueScaleOffset(e){return re(this.type)?Oe(this,e):e}}class z{constructor(e,s={},t={},n=null){this.definition=e,this.class=s[e.class],this.className=e.class,this.enums=t,this.data=n,this.name="name"in e?e.name:null,this.properties=null}getPropertyNames(){return Object.keys(this.class.properties)}includesData(e){return!!this.definition.properties[e]}dispose(){}_initProperties(e=D){const s={};for(const t in this.class.properties)s[t]=new e(this.enums,this.class.properties[t],this.definition.properties[t]);this.properties=s}}class Ve extends D{constructor(e,s,t=null){super(e,s,t),this.attribute=t.attribute}}class Ce extends z{constructor(...e){super(...e),this.isPropertyAttributeAccessor=!0,this._initProperties(Ve)}getData(e,s,t={}){const n=this.properties;P(n,t);for(const r in n)t[r]=this.getPropertyValue(r,e,s,t[r]);return t}getPropertyValue(e,s,t,n=null){if(s>=this.count)throw new Error("PropertyAttributeAccessor: Requested index is outside the range of the buffer.");const r=this.properties[e],o=r.type;if(r){if(!this.definition.properties[e])return r.resolveDefault(n)}else throw new Error("PropertyAttributeAccessor: Requested class property does not exist.");n=r.shapeToProperty(n);const a=t.getAttribute(r.attribute.toLowerCase());if(_(o)){const u=n.elements;for(let f=0,p=u.length;f<p;f<p)u[f]=a.getComponent(s,f)}else if(C(o))n.fromBufferAttribute(a,s);else if(o==="SCALAR"||o==="ENUM")n=a.getX(s);else throw new Error("StructuredMetadata.PropertyAttributeAccessor: BOOLEAN and STRING types are not supported by property attributes.");return n=r.adjustValueScaleOffset(n),n=r.resolveEnumsToStrings(n),n=r.resolveNoData(n),n}}class _e extends D{constructor(e,s,t=null){super(e,s,t),this.values=t.values,this.valueLength=Se(this.type),this.arrayOffsets=m(t,"arrayOffsets",null),this.stringOffsets=m(t,"stringOffsets",null),this.arrayOffsetType=m(t,"arrayOffsetType","UINT32"),this.stringOffsetType=m(t,"stringOffsetType","UINT32")}getArrayLengthFromId(e,s){let t=this.count;if(this.arrayOffsets!==null){const{arrayOffsets:n,arrayOffsetType:r}=this,o=V(r),a=new o(e[n]);t=a[s+1]-a[s]}return t}getIndexOffsetFromId(e,s){let t=s;if(this.arrayOffsets){const{arrayOffsets:n,arrayOffsetType:r}=this,o=V(r);t=new o(e[n])[t]}else this.array&&(t*=this.count);return t}}class Me extends z{constructor(...e){super(...e),this.isPropertyTableAccessor=!0,this.count=this.definition.count,this._initProperties(_e)}getData(e,s={}){const t=this.properties;P(t,s);for(const n in t)s[n]=this.getPropertyValue(n,e,s[n]);return s}_readValueAtIndex(e,s,t,n=null){const r=this.properties[e],{componentType:o,type:a}=r,u=this.data,f=u[r.values],p=V(o,a),c=new p(f),l=r.getIndexOffsetFromId(u,s);if(re(a)||a==="ENUM")return ie(c,(l+t)*r.valueLength,a,n);if(a==="STRING"){let y=l+t,d=0;if(r.stringOffsets!==null){const{stringOffsets:A,stringOffsetType:x}=r,I=V(x),w=new I(u[A]);d=w[y+1]-w[y],y=w[y]}const h=new Uint8Array(c.buffer,y,d);n=new TextDecoder().decode(h)}else if(a==="BOOLEAN"){const y=l+t,d=Math.floor(y/8),h=y%8;n=(c[d]>>h&1)===1}return n}getPropertyValue(e,s,t=null){if(s>=this.count)throw new Error("PropertyTableAccessor: Requested index is outside the range of the table.");const n=this.properties[e];if(n){if(!this.definition.properties[e])return n.resolveDefault(t)}else throw new Error("PropertyTableAccessor: Requested property does not exist.");const r=n.array,o=this.data,a=n.getArrayLengthFromId(o,s);if(t=n.shapeToProperty(t,a),r)for(let u=0,f=t.length;u<f;u++)t[u]=this._readValueAtIndex(e,s,u,t[u]);else t=this._readValueAtIndex(e,s,0,t);return t=n.adjustValueScaleOffset(t),t=n.resolveEnumsToStrings(t),t=n.resolveNoData(t),t}}const q=parseInt(ne)>=165,Pe=parseInt(ne)>=166,O=new Te,X=new se,U=new T,E=new class{constructor(){this._renderer=new ye,this._target=new G(1,1),this._texTarget=new G,this._quad=new we(new pe({blending:de,blendDst:me,blendSrc:Ae,uniforms:{map:{value:null},pixel:{value:new T}},vertexShader:`
				void main() {

					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				}
			`,fragmentShader:`
				uniform sampler2D map;
				uniform ivec2 pixel;

				void main() {

					gl_FragColor = texelFetch( map, pixel, 0 );

				}
			`}))}increaseSizeTo(i){this._target.setSize(Math.max(this._target.width,i),1)}readDataAsync(i){const{_renderer:e,_target:s}=this;return q?e.readRenderTargetPixelsAsync(s,0,0,i.length/4,1,i):Promise.resolve().then(()=>this.readData(i))}readData(i){const{_renderer:e,_target:s}=this;e.readRenderTargetPixels(s,0,0,i.length/4,1,i)}renderPixelToTarget(i,e,s){const{_quad:t,_renderer:n,_target:r,_texTarget:o}=this;if(Pe)O.min.copy(e),O.max.copy(e),O.max.x+=1,O.max.y+=1,n.initRenderTarget(r),n.copyTextureToTexture(i,r.texture,O,s,0);else{const a=n.autoClear,u=n.getRenderTarget(),f=n.getScissorTest();n.getScissor(X),o.setSize(i.image.width,i.image.height),n.setRenderTarget(o),U.set(0,0),q?n.copyTextureToTexture(i,o.texture,null,U):n.copyTextureToTexture(U,i,o.texture),t.material.uniforms.map.value=o.texture,t.material.uniforms.pixel.value.copy(e),n.setRenderTarget(r),n.setScissorTest(!0),n.setScissor(s.x,s.y,1,1),n.autoClear=!1,t.render(n),n.setScissorTest(f),n.setScissor(X),n.setRenderTarget(u),n.autoClear=a,o.dispose()}}},k=new T,$=new T,Q=new T;function Re(i,e){return e===0?i.getAttribute("uv"):i.getAttribute(`uv${e}`)}function oe(i,e,s=new Array(3)){let t=3*e,n=3*e+1,r=3*e+2;return i.index&&(t=i.index.getX(t),n=i.index.getX(n),r=i.index.getX(r)),s[0]=t,s[1]=n,s[2]=r,s}function ae(i,e,s,t,n){const[r,o,a]=t,u=Re(i,e);k.fromBufferAttribute(u,r),$.fromBufferAttribute(u,o),Q.fromBufferAttribute(u,a),n.set(0,0,0).addScaledVector(k,s.x).addScaledVector($,s.y).addScaledVector(Q,s.z)}function ue(i,e,s,t){const n=i.x-Math.floor(i.x),r=i.y-Math.floor(i.y),o=Math.floor(n*e%e),a=Math.floor(r*s%s);return t.set(o,a),t}const W=new T,H=new T,J=new T;class De extends D{constructor(e,s,t=null){super(e,s,t),this.channels=m(t,"channels",[0]),this.index=m(t,"index",null),this.texCoord=m(t,"texCoord",null),this.valueLength=parseInt(this.type.replace(/[^0-9]/g,""))||1}readDataFromBuffer(e,s,t=null){const n=this.type;if(n==="BOOLEAN"||n==="STRING")throw new Error("PropertyTextureAccessor: BOOLEAN and STRING types not supported.");return ie(e,s*this.valueLength,n,t)}}class ge extends z{constructor(...e){super(...e),this.isPropertyTextureAccessor=!0,this._asyncRead=!1,this._initProperties(De)}getData(e,s,t,n={}){const r=this.properties;P(r,n);const o=Object.keys(r),a=o.map(u=>n[u]);return this.getPropertyValuesAtTexel(o,e,s,t,a),o.forEach((u,f)=>n[u]=a[f]),n}async getDataAsync(e,s,t,n={}){const r=this.properties;P(r,n);const o=Object.keys(r),a=o.map(u=>n[u]);return await this.getPropertyValuesAtTexelAsync(o,e,s,t,a),o.forEach((u,f)=>n[u]=a[f]),n}getPropertyValuesAtTexelAsync(...e){this._asyncRead=!0;const s=this.getPropertyValuesAtTexel(...e);return this._asyncRead=!1,s}getPropertyValuesAtTexel(e,s,t,n,r=[]){for(;r.length<e.length;)r.push(null);r.length=e.length,E.increaseSizeTo(r.length);const o=this.data,a=this.definition.properties,u=this.properties,f=oe(n,s);for(let l=0,y=e.length;l<y;l++){const d=e[l];if(!a[d])continue;const h=u[d],A=o[h.index];ae(n,h.texCoord,t,f,W),ue(W,A.image.width,A.image.height,H),J.set(l,0),E.renderPixelToTarget(A,H,J)}const p=new Uint8Array(e.length*4);if(this._asyncRead)return E.readDataAsync(p).then(()=>(c.call(this),r));return E.readData(p),c.call(this),r;function c(){for(let l=0,y=e.length;l<y;l++){const d=e[l],h=u[d],A=h.type;if(r[l]=j(h,r[l]),h){if(!a[d]){r[l]=h.resolveDefault(r);continue}}else throw new Error("PropertyTextureAccessor: Requested property does not exist.");const x=h.valueLength*(h.count||1),I=h.channels.map(b=>p[4*l+b]),w=h.componentType,g=V(w,A),F=new g(x);if(new Uint8Array(F.buffer).set(I),h.array){const b=r[l];for(let N=0,ce=b.length;N<ce;N++)b[N]=h.readDataFromBuffer(F,N,b[N])}else r[l]=h.readDataFromBuffer(F,0,r[l]);r[l]=h.adjustValueScaleOffset(r[l]),r[l]=h.resolveEnumsToStrings(r[l]),r[l]=h.resolveNoData(r[l])}}}dispose(){this.data.forEach(e=>{e&&(e.dispose(),e.image instanceof ImageBitmap&&e.image.close())})}}class K{constructor(e,s,t,n=null,r=null){const{schema:o,propertyTables:a=[],propertyTextures:u=[],propertyAttributes:f=[]}=e,{enums:p,classes:c}=o,l=a.map(h=>new Me(h,c,p,t));let y=[],d=[];n&&(n.propertyTextures&&(y=n.propertyTextures.map(h=>new ge(u[h],c,p,s))),n.propertyAttributes&&(d=n.propertyAttributes.map(h=>new Ce(f[h],c,p)))),this.schema=o,this.tableAccessors=l,this.textureAccessors=y,this.attributeAccessors=d,this.object=r,this.textures=s,this.nodeMetadata=n}getPropertyTableData(e,s,t=null){if(!Array.isArray(e)||!Array.isArray(s))t=t||{},t=this.tableAccessors[e].getData(s,t);else{t=t||[];const n=Math.min(e.length,s.length);t.length=n;for(let r=0;r<n;r++){const o=this.tableAccessors[e[r]];t[r]=o.getData(s[r],t[r])}}return t}getPropertyTableInfo(e=null){if(e===null&&(e=this.tableAccessors.map((s,t)=>t)),Array.isArray(e))return e.map(s=>{const t=this.tableAccessors[s];return{name:t.name,className:t.definition.class}});{const s=this.tableAccessors[e];return{name:s.name,className:s.definition.class}}}getPropertyTextureData(e,s,t=[]){const n=this.textureAccessors;t.length=n.length;for(let r=0;r<n.length;r++){const o=n[r];t[r]=o.getData(e,s,this.object.geometry,t[r])}return t}async getPropertyTextureDataAsync(e,s,t=[]){const n=this.textureAccessors;t.length=n.length;const r=[];for(let o=0;o<n.length;o++){const u=n[o].getDataAsync(e,s,this.object.geometry,t[o]).then(f=>{t[o]=f});r.push(u)}return await Promise.all(r),t}getPropertyTextureInfo(){return this.textureAccessors}getPropertyAttributeData(e,s=[]){const t=this.attributeAccessors;s.length=t.length;for(let n=0;n<t.length;n++){const r=t[n];s[n]=r.getData(e,this.object.geometry,s[n])}return s}getPropertyAttributeInfo(){return this.attributeAccessors.map(e=>({name:e.name,className:e.definition.class}))}dispose(){this.textureAccessors.forEach(e=>e.dispose()),this.tableAccessors.forEach(e=>e.dispose()),this.attributeAccessors.forEach(e=>e.dispose())}}const S="EXT_structural_metadata";function Fe(i,e=[]){var n;const s=((n=i.json.textures)==null?void 0:n.length)||0,t=new Array(s).fill(null);return e.forEach(({properties:r})=>{for(const o in r){const{index:a}=r[o];t[a]===null&&(t[a]=i.loadTexture(a))}}),Promise.all(t)}function Ue(i,e=[]){var n;const s=((n=i.json.bufferViews)==null?void 0:n.length)||0,t=new Array(s).fill(null);return e.forEach(({properties:r})=>{for(const o in r){const{values:a,arrayOffsets:u,stringOffsets:f}=r[o];t[a]===null&&(t[a]=i.loadBufferView(a)),t[u]===null&&(t[u]=i.loadBufferView(u)),t[f]===null&&(t[f]=i.loadBufferView(f))}}),Promise.all(t)}class Ge{constructor(e){this.parser=e,this.name=S}async afterRoot({scene:e,parser:s}){const t=s.json.extensionsUsed;if(!t||!t.includes(S))return;let n=null,r=s.json.extensions[S];if(r.schemaUri){const{manager:f,path:p,requestHeader:c,crossOrigin:l}=s.options,y=new URL(r.schemaUri,p).toString(),d=new xe(f);d.setCrossOrigin(l),d.setResponseType("json"),d.setRequestHeader(c),n=d.loadAsync(y).then(h=>{r={...r,schema:h}})}const[o,a]=await Promise.all([Fe(s,r.propertyTextures),Ue(s,r.propertyTables),n]),u=new K(r,o,a);e.userData.structuralMetadata=u,e.traverse(f=>{if(s.associations.has(f)){const{meshes:p,primitives:c}=s.associations.get(f),l=s.json.meshes[p].primitives[c];if(l&&l.extensions&&l.extensions[S]){const y=l.extensions[S];f.userData.structuralMetadata=new K(r,o,a,y,f)}else f.userData.structuralMetadata=u}})}}const Z=new T,Y=new T,ee=new T;function Le(i){return i.x>i.y&&i.x>i.z?0:i.y>i.z?1:2}class Be{constructor(e,s,t){this.geometry=e,this.textures=s,this.data=t,this._asyncRead=!1,this.featureIds=t.featureIds.map(n=>{const{texture:r,...o}=n,a={label:null,propertyTable:null,nullFeatureId:null,...o};return r&&(a.texture={texCoord:0,channels:[0],...r}),a})}getTextures(){return this.textures}getFeatureInfo(){return this.featureIds}getFeaturesAsync(...e){this._asyncRead=!0;const s=this.getFeatures(...e);return this._asyncRead=!1,s}getFeatures(e,s){const{geometry:t,textures:n,featureIds:r}=this,o=new Array(r.length).fill(null),a=r.length;E.increaseSizeTo(a);const u=oe(t,e),f=u[Le(s)];for(let l=0,y=r.length;l<y;l++){const d=r[l],h="nullFeatureId"in d?d.nullFeatureId:null;if("texture"in d){const A=n[d.texture.index];ae(t,d.texture.texCoord,s,u,Z),ue(Z,A.image.width,A.image.height,Y),ee.set(l,0),E.renderPixelToTarget(n[d.texture.index],Y,ee)}else if("attribute"in d){const x=t.getAttribute(`_feature_id_${d.attribute}`).getX(f);x!==h&&(o[l]=x)}else{const A=f;A!==h&&(o[l]=A)}}const p=new Uint8Array(a*4);if(this._asyncRead)return E.readDataAsync(p).then(()=>(c(),o));return E.readData(p),c(),o;function c(){const l=new Uint32Array(1);for(let y=0,d=r.length;y<d;y++){const h=r[y],A="nullFeatureId"in h?h.nullFeatureId:null;if("texture"in h){const{channels:x}=h.texture,I=x.map(g=>p[4*y+g]);new Uint8Array(l.buffer).set(I);const w=l[0];w!==A&&(o[y]=w)}}}}dispose(){this.textures.forEach(e=>{e&&(e.dispose(),e.image instanceof ImageBitmap&&e.image.close())})}}const R="EXT_mesh_features";function te(i,e,s){i.traverse(t=>{if(e.associations.has(t)){const{meshes:n,primitives:r}=e.associations.get(t),o=e.json.meshes[n].primitives[r];o&&o.extensions&&o.extensions[R]&&s(t,o.extensions[R])}})}class ve{constructor(e){this.parser=e,this.name=R}async afterRoot({scene:e,parser:s}){var a;const t=s.json.extensionsUsed;if(!t||!t.includes(R))return;const n=((a=s.json.textures)==null?void 0:a.length)||0,r=new Array(n).fill(null);te(e,s,(u,{featureIds:f})=>{f.forEach(p=>{if(p.texture&&r[p.texture.index]===null){const c=p.texture.index;r[c]=s.loadTexture(c)}})});const o=await Promise.all(r);te(e,s,(u,f)=>{u.userData.meshFeatures=new Be(u.geometry,o,f)})}}export{ve as G,Ge as a};
