import{j as S,k as _,an as A,V as F,Q as G,i as l}from"./three.module-DpclfMcJ.js";import{E as N,c as z,N as Z,D as j,m as w,a as H,s as L,b as q}from"./EnvironmentControls-CYEuz71t.js";import{E as k}from"./Ellipsoid-Cnb0UTwk.js";const p=new S,C=new S,f=new _,s=new _,y=new _,c=new _,R=new _,v=new _,V=new _,u=new G,b=new _,D=new _,E={},g=new A,T=new k,P=new F,Q=400;class X extends N{get ellipsoid(){return this.tilesRenderer?this.tilesRenderer.ellipsoid:null}get tilesGroup(){return this.tilesRenderer?this.tilesRenderer.group:null}constructor(t=null,o=null,i=null,e=null){super(t,o,i),this.isGlobeControls=!0,this._dragMode=0,this._rotationMode=0,this.maxZoom=.01,this.useFallbackPlane=!1,this.reorientOnDrag=!1,this.dragQuaternion=new G,this.setTilesRenderer(e)}setScene(t){t===null&&this.tilesRenderer!==null?super.setScene(this.tilesRenderer.group):super.setScene(t)}getPivotPoint(t){const{camera:o,tilesGroup:i,ellipsoid:e}=this;return c.set(0,0,-1).transformDirection(o.matrixWorld),p.copy(i.matrixWorld).invert(),g.origin.copy(o.position),g.direction.copy(c),g.applyMatrix4(p),z(g,e,s),s.applyMatrix4(i.matrixWorld),(super.getPivotPoint(t)===null||t.distanceTo(g.origin)>s.distanceTo(g.origin))&&t.copy(s),t}getVectorToCenter(t){const{tilesGroup:o,camera:i}=this;return t.setFromMatrixPosition(o.matrixWorld).sub(i.position)}getDistanceToCenter(){return this.getVectorToCenter(s).length()}getUpDirection(t,o){const{tilesGroup:i,ellipsoid:e}=this;p.copy(i.matrixWorld).invert(),s.copy(t).applyMatrix4(p),e.getPositionToNormal(s,o),o.transformDirection(i.matrixWorld)}getCameraUpDirection(t){const{tilesGroup:o,ellipsoid:i,camera:e}=this;e.isOrthographicCamera?(this._getVirtualOrthoCameraPosition(s),p.copy(o.matrixWorld).invert(),s.applyMatrix4(p),i.getPositionToNormal(s,t),t.transformDirection(o.matrixWorld)):this.getUpDirection(e.position,t)}update(t=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.tilesGroup||!this.camera||t===0)return;const{camera:o,pivotMesh:i}=this;this._isNearControls()?this.scaleZoomOrientationAtEdges=this.zoomDelta<0:(this.state!==Z&&this._dragMode!==1&&this._rotationMode!==1&&(i.visible=!1),this.scaleZoomOrientationAtEdges=!1),super.update(t),this.adjustCamera(o)}adjustCamera(t){super.adjustCamera(t);const{tilesGroup:o,ellipsoid:i}=this;if(t.isPerspectiveCamera){const e=s.setFromMatrixPosition(o.matrixWorld).sub(t.position).length(),r=Math.max(...i.radius),a=.25*r,n=l.clamp((e-r)/a,0,1),h=l.lerp(1,1e3,n);t.near=Math.max(h,e-r-a);const m=p.copy(o.matrixWorld).invert();f.copy(t.position).applyMatrix4(m),i.getPositionToCartographic(f,E);const d=Math.max(i.getPositionElevation(f),Q),x=i.calculateHorizonDistance(E.lat,d);t.far=x*2.5+.1,t.updateProjectionMatrix()}else{this._getVirtualOrthoCameraPosition(t.position,t),t.updateMatrixWorld(),p.copy(t.matrixWorld).invert(),s.setFromMatrixPosition(o.matrixWorld).applyMatrix4(p);const e=-s.z;t.near=e-Math.max(...i.radius)*1.1,t.far=e+.1,t.position.addScaledVector(c,t.near),t.far-=t.near,t.near=0,t.updateProjectionMatrix(),t.updateMatrixWorld()}}resetState(){super.resetState(),this._dragMode=0,this._rotationMode=0}_updatePosition(t){if(this.state!==j){const{enableDamping:o,tilesGroup:i,dragQuaternion:e,dragInertia:r,camera:a}=this;o&&(e.w===1&&(e.x!==0||e.y!==0||e.z!==0)&&(e.w=Math.min(e.w,1-1e-9)),y.setFromMatrixPosition(i.matrixWorld),u.identity().slerp(e,r.x*t),w(y,u,C),a.matrixWorld.premultiply(C),a.matrixWorld.decompose(a.position,a.quaternion,s))}else{this._dragMode===0&&(this._dragMode=this._isNearControls()?1:-1);const{raycaster:o,camera:i,pivotPoint:e,pointerTracker:r,domElement:a,tilesGroup:n}=this,h=f,m=v;r.getCenterPoint(P),H(P.x,P.y,a,P),L(o,P,i),p.copy(n.matrixWorld).invert(),o.ray.applyMatrix4(p);const d=s.copy(e).applyMatrix4(p).length();T.radius.setScalar(d),i.isPerspectiveCamera?T.intersectRay(o.ray,s)||q(o.ray,d,s):z(o.ray,T,s),s.applyMatrix4(n.matrixWorld),y.setFromMatrixPosition(n.matrixWorld),h.subVectors(e,y).normalize(),m.subVectors(s,y).normalize(),u.setFromUnitVectors(m,h),w(y,u,C),i.matrixWorld.premultiply(C),i.matrixWorld.decompose(i.position,i.quaternion,s);const{dragInertia:x,dragQuaternion:M}=this;r.getMoveDistance()/t<2*window.devicePixelRatio?(M.slerp(u,.5),x.set(1/t,0,0)):(M.copy(u),x.set(1/t,0,0))}this._alignCameraUp(this.up)}_updateRotation(...t){this._rotationMode===1||this._isNearControls()?(this._rotationMode=1,super._updateRotation(...t)):(this.pivotMesh.visible=!1,this._rotationMode=-1),this._alignCameraUp(this.up)}_updateZoom(){const{zoomDelta:t,ellipsoid:o,zoomSpeed:i,zoomPoint:e,camera:r,maxZoom:a}=this,n=l.clamp(l.mapLinear(Math.abs(t),0,20,0,1),0,1);if(this._isNearControls()||t>0){if(this._updateZoomDirection(),t<0&&(this.zoomPointSet||this._updateZoomPoint())){c.set(0,0,-1).transformDirection(r.matrixWorld).normalize(),D.copy(this.up).multiplyScalar(-1),this.getUpDirection(e,b);const h=l.clamp(l.mapLinear(-b.dot(D),1,.95,0,1),0,1),m=1-c.dot(D),d=r.isOrthographicCamera?.05:1,x=l.clamp(n*3,0,1),M=Math.min(h*m*d*x,.1);D.lerpVectors(c,D,M).normalize(),u.setFromUnitVectors(c,D),w(e,u,C),r.matrixWorld.premultiply(C),r.matrixWorld.decompose(r.position,r.quaternion,D),this.zoomDirection.subVectors(e,r.position).normalize()}super._updateZoom()}else if(r.isPerspectiveCamera){const h=this._getPerspectiveTransitionDistance(),m=this._getMaxPerspectiveDistance(),d=l.mapLinear(this.getDistanceToCenter(),h,m,0,1);this._tiltTowardsCenter(l.lerp(0,.4,d*n)),this._alignCameraUpToNorth(l.lerp(0,.2,d*n));const x=this.getDistanceToCenter()-o.radius.x,M=t*x*i*.0025,W=Math.max(M,Math.min(this.getDistanceToCenter()-m,0));this.getVectorToCenter(s).normalize(),this.camera.position.addScaledVector(s,W),this.camera.updateMatrixWorld(),this.zoomDelta=0}else{const h=this._getOrthographicTransitionZoom(),m=this._getMinOrthographicZoom(),d=l.mapLinear(r.zoom,h,m,0,1);this._tiltTowardsCenter(l.lerp(0,.4,d*n)),this._alignCameraUpToNorth(l.lerp(0,.2,d*n));const x=this.zoomDelta,M=Math.pow(.95,Math.abs(x*.05)),W=x>0?1/Math.abs(M):M,O=m/r.zoom,U=Math.max(W*i,Math.min(O,1));r.zoom=Math.min(a,r.zoom*U),r.updateProjectionMatrix(),this.zoomDelta=0,this.zoomDirectionSet=!1}}_alignCameraUpToNorth(t){const{tilesGroup:o}=this;V.set(0,0,1).transformDirection(o.matrixWorld),this._alignCameraUp(V,t)}_alignCameraUp(t,o=null){const{camera:i}=this;c.set(0,0,-1).transformDirection(i.matrixWorld),R.set(-1,0,0).transformDirection(i.matrixWorld),v.crossVectors(t,c),o===null&&(o=1-Math.abs(c.dot(t)),o=l.mapLinear(o,0,1,-.01,1),o=l.clamp(o,0,1)**2),v.lerp(R,1-o).normalize(),u.setFromUnitVectors(R,v),i.quaternion.premultiply(u),i.updateMatrixWorld()}_tiltTowardsCenter(t){const{camera:o,tilesGroup:i}=this;c.set(0,0,-1).transformDirection(o.matrixWorld).normalize(),s.setFromMatrixPosition(i.matrixWorld).sub(o.position).normalize(),s.lerp(c,1-t).normalize(),u.setFromUnitVectors(c,s),o.quaternion.premultiply(u),o.updateMatrixWorld()}_getPerspectiveTransitionDistance(){const{camera:t,ellipsoid:o}=this;if(!t.isPerspectiveCamera)throw new Error;const i=Math.max(...o.radius),e=2*Math.atan(Math.tan(l.DEG2RAD*t.fov*.5)*t.aspect),r=i/Math.tan(l.DEG2RAD*t.fov*.5),a=i/Math.tan(e*.5);return Math.max(r,a)}_getMaxPerspectiveDistance(){const{camera:t,ellipsoid:o}=this;if(!t.isPerspectiveCamera)throw new Error;const i=Math.max(...o.radius),e=2*Math.atan(Math.tan(l.DEG2RAD*t.fov*.5)*t.aspect),r=i/Math.tan(l.DEG2RAD*t.fov*.5),a=i/Math.tan(e*.5);return 2*Math.max(r,a)}_getOrthographicTransitionZoom(){const{camera:t,ellipsoid:o}=this;if(!t.isOrthographicCamera)throw new Error;const i=t.top-t.bottom,e=t.right-t.left,r=Math.max(i,e),n=2*Math.max(...o.radius);return 2*r/n}_getMinOrthographicZoom(){const{camera:t,ellipsoid:o}=this;if(!t.isOrthographicCamera)throw new Error;const i=t.top-t.bottom,e=t.right-t.left,r=Math.min(i,e),n=2*Math.max(...o.radius);return .7*r/n}_getVirtualOrthoCameraPosition(t,o=this.camera){const{tilesGroup:i,ellipsoid:e}=this;if(!o.isOrthographicCamera)throw new Error;p.copy(i.matrixWorld).invert(),g.origin.copy(o.position),g.direction.set(0,0,-1).transformDirection(o.matrixWorld),g.applyMatrix4(p),z(g,e,f),f.applyMatrix4(i.matrixWorld);const r=o.top-o.bottom,a=o.right-o.left,n=Math.max(r,a)/o.zoom;c.set(0,0,-1).transformDirection(o.matrixWorld);const h=f.sub(o.position).dot(c);t.copy(o.position).addScaledVector(c,h-n*4)}_isNearControls(){const{camera:t}=this;return t.isPerspectiveCamera?this.getDistanceToCenter()<this._getPerspectiveTransitionDistance():t.zoom>this._getOrthographicTransitionZoom()}}export{X as G};
