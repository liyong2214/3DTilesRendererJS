import{g as at,a$ as ct,b as ht,V as S,j as ot,an as lt,k as P,ao as nt,aD as pt,R as dt,s as ut,Q as rt,i as mt}from"./three.module-DpclfMcJ.js";class ft extends at{constructor(){super(new ct(0,0),new Pt),this.renderOrder=1/0}onBeforeRender(t){const e=this.material.uniforms;t.getSize(e.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class Pt extends ht{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new S},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:`

				uniform float pixelRatio;
				uniform float size;
				uniform float thickness;
				uniform vec2 resolution;
				varying vec2 vUv;

				void main() {

					vUv = uv;

					float aspect = resolution.x / resolution.y;
					vec2 offset = uv * 2.0 - vec2( 1.0 );
					offset.y *= aspect;

					vec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					screenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;

					gl_Position = screenPoint;

				}
			`,fragmentShader:`

				uniform float size;
				uniform float thickness;
				uniform float opacity;

				varying vec2 vUv;
				void main() {

					float ht = 0.5 * thickness;
					float planeDim = size + thickness;
					float offset = ( planeDim - ht - 2.0 ) / planeDim;
					float texelThickness = ht / planeDim;

					vec2 vec = vUv * 2.0 - vec2( 1.0 );
					float dist = abs( length( vec ) - offset );
					float fw = fwidth( dist ) * 0.5;
					float a = smoothstep( texelThickness - fw, texelThickness + fw, dist );

					gl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );

				}
			`})}}const Q=new S,Y=new S;class vt{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new S,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new S,this.hoverSet=!1}updateFrame(){const{previousPositions:t,pointerPositions:e}=this;for(const i in e)t[i].copy(e[i])}setHoverEvent(t){(t.pointerType==="mouse"||t.type==="wheel")&&(this.getAdjustedPointer(t,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(t){return this.pointerType!==null?(this.getCenterPoint(t),t):this.hoverSet?(t.copy(this.hoverPosition),t):null}getAdjustedPointer(t,e){const s=(this.domElement?this.domElement:t.target).getBoundingClientRect(),n=t.clientX-s.left,c=t.clientY-s.top;e.set(n,c)}addPointer(t){const e=t.pointerId,i=new S;this.getAdjustedPointer(t,i),this.pointerOrder.push(e),this.pointerPositions[e]=i,this.previousPositions[e]=i.clone(),this.startPositions[e]=i.clone(),this.getPointerCount()===1&&(this.pointerType=t.pointerType,this.buttons=t.buttons)}updatePointer(t){const e=t.pointerId;return e in this.pointerPositions?(this.getAdjustedPointer(t,this.pointerPositions[e]),!0):!1}deletePointer(t){const e=t.pointerId,i=this.pointerOrder;i.splice(i.indexOf(e),1),delete this.pointerPositions[e],delete this.previousPositions[e],delete this.startPositions[e],this.getPointerCount.length===0&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(t,e=this.pointerPositions){const i=this.pointerOrder;if(this.getPointerCount()===1||this.getPointerType()==="mouse"){const s=i[0];return t.copy(e[s]),t}else if(this.getPointerCount()===2){const s=this.pointerOrder[0],n=this.pointerOrder[1],c=e[s],p=e[n];return t.addVectors(c,p).multiplyScalar(.5),t}return null}getPreviousCenterPoint(t){return this.getCenterPoint(t,this.previousPositions)}getStartCenterPoint(t){return this.getCenterPoint(t,this.startPositions)}getMoveDistance(){return this.getCenterPoint(Q),this.getPreviousCenterPoint(Y),Q.sub(Y).length()}getTouchPointerDistance(t=this.pointerPositions){if(this.getPointerCount()<=1||this.getPointerType()==="mouse")return 0;const{pointerOrder:e}=this,i=e[0],s=e[1],n=t[i],c=t[s];return n.distanceTo(c)}getPreviousTouchPointerDistance(){return this.getTouchPointerDistance(this.previousPositions)}getStartTouchPointerDistance(){return this.getTouchPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return this.getPointerType()==="touch"}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(this.buttons&1)}isRightClicked(){return!!(this.buttons&2)}}const x=new ot,$=new lt,q=new P;function A(l,t,e){return e.makeTranslation(-l.x,-l.y,-l.z),x.makeRotationFromQuaternion(t),e.premultiply(x),x.makeTranslation(l.x,l.y,l.z),e.premultiply(x),e}function R(l,t,e,i){i.x=(l-e.offsetLeft)/e.clientWidth*2-1,i.y=-((t-e.offsetTop)/e.clientHeight)*2+1,i.isVector3&&(i.z=0)}function Dt(l,t,e){return t.intersectRay(l,e)?e:(x.makeScale(...t.radius).invert(),$.copy(l).applyMatrix4(x),q.set(0,0,0),$.closestPointToPoint(q,e).normalize(),x.makeScale(...t.radius),e.applyMatrix4(x))}function Mt(l,t,e){const i=l.origin.length(),s=Math.acos(t/i);e.copy(l.origin).multiplyScalar(-1).normalize();const n=q.crossVectors(e,l.direction).normalize();e.multiplyScalar(-1).applyAxisAngle(n,-s).normalize().multiplyScalar(t)}function W(l,t,e){const{origin:i,direction:s}=l.ray;i.set(t.x,t.y,-1).unproject(e),s.set(t.x,t.y,1).unproject(e).sub(i),l.near=0,l.far=s.length(),l.camera=e,s.normalize()}const _=0,E=1,b=2,U=3,V=4,F=.05,Z=.025,gt=1e-4,yt=.01,D=new ot,I=new P,y=new P,j=new P,X=new P,z=new P,M=new rt,J=new nt,f=new P,H=new P,B=new P,St=new rt,L=new S,u=new S,K=new S,T=new S,N=new S,tt=new S,et={type:"change"},it={type:"start"},st={type:"end"};class xt extends pt{get enabled(){return this._enabled}set enabled(t){t!==this.enabled&&(this._enabled=t,this.resetState(),this.pointerTracker.reset(),this.enabled||(this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0)))}constructor(t=null,e=null,i=null,s=null){super(),this.isEnvironmentControls=!0,this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.enableDamping=!1,this.dampingFactor=.15,this.reorientOnDrag=!0,this.scaleZoomOrientationAtEdges=!1,this.state=_,this.pointerTracker=new vt,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new P,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new P,this.zoomPoint=new P,this.zoomDelta=0,this.rotationInertia=new S,this.dragInertia=new P,this.pivotMesh=new ft,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new dt,this.raycaster.firstHitOnly=!0,this.up=new P(0,1,0),this.clock=new ut,this.fallbackPlane=new nt(new P(0,1,0),0),this.useFallbackPlane=!0,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=_,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,i&&this.attach(i),e&&this.setCamera(e),t&&this.setScene(t),s&&this.setTilesRenderer(s)}setScene(t){this.scene=t}setCamera(t){this.camera=t,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.raycaster.camera=t,this.resetState()}setTilesRenderer(t){this.tilesRenderer&&this.tilesRenderer.removeEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.tilesRenderer=t,this.tilesRenderer!==null&&(this.tilesRenderer.addEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.scene===null&&this.setScene(this.tilesRenderer.group))}attach(t){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=t,this.pointerTracker.domElement=t,t.style.touchAction="none";let e=!1;const i=o=>{o.preventDefault()},s=o=>{o.key==="Shift"&&(e=!0)},n=o=>{o.key==="Shift"&&(e=!1)},c=o=>{o.preventDefault();const{camera:a,raycaster:m,domElement:C,up:k,pivotMesh:w,pointerTracker:g}=this;if(g.addPointer(o),this.needsUpdate=!0,g.isPointerTouch()){if(w.visible=!1,g.getPointerCount()===0)C.setPointerCapture(o.pointerId);else if(g.getPointerCount()>2){this.resetState();return}}g.getCenterPoint(u),R(u.x,u.y,C,u),W(m,u,a);const G=Math.abs(m.ray.direction.dot(k));if(G<F||G<Z)return;const O=this._raycast(m);O&&(g.getPointerCount()===2||g.isRightClicked()||g.isLeftClicked()&&e?(this.setState(g.isPointerTouch()?V:b),this.pivotPoint.copy(O.point),this.pivotMesh.position.copy(O.point),this.pivotMesh.updateMatrixWorld(),this.scene.add(this.pivotMesh)):g.isLeftClicked()&&(this.setState(E),this.pivotPoint.copy(O.point),this.pivotMesh.position.copy(O.point),this.pivotMesh.updateMatrixWorld(),this.scene.add(this.pivotMesh)))};let p=!1;const d=o=>{o.preventDefault(),this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.state!==_&&(this.needsUpdate=!0);const{pointerTracker:a}=this;a.setHoverEvent(o),a.updatePointer(o)&&(a.isPointerTouch()&&a.getPointerCount()===2&&(p||(p=!0,queueMicrotask(()=>{p=!1,a.getCenterPoint(N);const m=a.getStartTouchPointerDistance(),C=a.getTouchPointerDistance(),k=C-m;if(this.state===_||this.state===V){a.getCenterPoint(N),a.getStartCenterPoint(tt);const w=2*window.devicePixelRatio,g=N.distanceTo(tt);(Math.abs(k)>w||g>w)&&(Math.abs(k)>g?(this.setState(U),this.zoomDirectionSet=!1):this.setState(b))}if(this.state===U){const w=a.getPreviousTouchPointerDistance();this.zoomDelta+=C-w}else this.state===b&&(this.pivotMesh.visible=this.enabled)}))),this.dispatchEvent(et))},h=o=>{const{pointerTracker:a}=this;a.deletePointer(o),a.getPointerType()==="touch"&&a.getPointerCount()===0&&t.releasePointerCapture(o.pointerId),this.resetState(),this.needsUpdate=!0},v=o=>{o.preventDefault();const{pointerTracker:a}=this;a.setHoverEvent(o),a.updatePointer(o),this.dispatchEvent(it);let m;switch(o.deltaMode){case 2:m=o.deltaY*100;break;case 1:m=o.deltaY*16;break;case 0:m=o.deltaY;break}const C=Math.sign(m),k=Math.log(Math.abs(m)+1);this.zoomDelta-=3*C*k,this.needsUpdate=!0,this._lastUsedState=U,this.dispatchEvent(st)},r=o=>{const{pointerTracker:a}=this;e=!1,o.buttons!==a.getPointerButtons()&&(a.deletePointer(o),this.resetState())};t.addEventListener("contextmenu",i),t.addEventListener("keydown",s),t.addEventListener("keyup",n),t.addEventListener("pointerdown",c),t.addEventListener("pointermove",d),t.addEventListener("pointerup",h),t.addEventListener("wheel",v,{passive:!1}),t.addEventListener("pointerenter",r),this._detachCallback=()=>{t.removeEventListener("contextmenu",i),t.removeEventListener("keydown",s),t.removeEventListener("keyup",n),t.removeEventListener("pointerdown",c),t.removeEventListener("pointermove",d),t.removeEventListener("pointerup",h),t.removeEventListener("wheel",v),t.removeEventListener("pointerenter",r)}}getUpDirection(t,e){e.copy(this.up)}getCameraUpDirection(t){this.getUpDirection(this.camera.position,t)}getPivotPoint(t){return this._lastUsedState===U?this._zoomPointWasSet?(t.copy(this.zoomPoint),t):null:this._lastUsedState===b||this._lastUsedState===E?(t.copy(this.pivotPoint),t):null}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}resetState(){this.state!==_&&this.dispatchEvent(st),this.state=_,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=this.enabled,this.actionHeightOffset=0}setState(t=this.state,e=!0){this.state!==t&&(this.state===_&&e&&this.dispatchEvent(it),this.pivotMesh.visible=this.enabled,this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0),this.state=t,t!==_&&t!==V&&(this._lastUsedState=t))}update(t=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.camera||t===0)return;const{camera:e,cameraRadius:i,pivotPoint:s,up:n,state:c,adjustHeight:p}=this;e.updateMatrixWorld(),this.getCameraUpDirection(f),this._upInitialized||(this._upInitialized=!0,this.up.copy(f));const d=this._inertiaNeedsUpdate();if(this.needsUpdate||d){const r=this.zoomDelta;(c===U||r!==0)&&(this._updateZoom(),this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0)),this._updatePosition(t),this._updateRotation(t),(c!==_||r!==0||d)&&this.dispatchEvent(et),this.needsUpdate=!1}d&&this._updateInertiaDamping(t);const h=e.isOrthographicCamera?null:p&&this._getPointBelowCamera()||null,v=e.isOrthographicCamera?s:h&&h.point||null;if(this.getCameraUpDirection(f),this._setFrame(f,v),(this.state===E||this.state===b)&&this.actionHeightOffset!==0){const{actionHeightOffset:r}=this;e.position.addScaledVector(n,-r),s.addScaledVector(n,-r),h&&(h.distance-=r)}if(this.actionHeightOffset=0,h){const r=h.distance;if(r<i){const o=i-r;e.position.addScaledVector(n,o),s.addScaledVector(n,o),this.actionHeightOffset=o}}this.pointerTracker.updateFrame()}adjustCamera(t){const{adjustHeight:e,cameraRadius:i}=this;if(t.isPerspectiveCamera){this.getUpDirection(t.position,f);const s=e&&this._getPointBelowCamera(t.position,f)||null;if(s){const n=s.distance;n<i&&t.position.addScaledVector(f,i-n)}}}dispose(){this.detach()}_updateInertiaDamping(t){const{rotationInertia:e,dragInertia:i,enableDamping:s,dampingFactor:n}=this,c=Math.pow(2,-t/n);e.multiplyScalar(c),(e.lengthSq()<gt||!s)&&e.set(0,0),i.multiplyScalar(c),(i.lengthSq()<yt||!s)&&i.set(0,0,0)}_inertiaNeedsUpdate(){const{rotationInertia:t,dragInertia:e}=this;return t.lengthSq()!==0||e.lengthSq()!==0}_updateZoom(){const{zoomPoint:t,zoomDirection:e,camera:i,minDistance:s,maxDistance:n,pointerTracker:c,domElement:p,minZoom:d,maxZoom:h,zoomSpeed:v}=this;let r=this.zoomDelta;if(this.zoomDelta=0,!!c.getLatestPoint(u))if(i.isOrthographicCamera)if(this._updateZoomDirection(),this.zoomPointSet||this._updateZoomPoint()){H.unproject(i);const o=Math.pow(.95,Math.abs(r*.05)),a=r>0?1/Math.abs(o):o;i.zoom=Math.max(d,Math.min(h,i.zoom*a*v)),i.updateProjectionMatrix(),R(u.x,u.y,p,B),B.unproject(i),i.position.sub(B).add(H),i.updateMatrixWorld()}else{const o=Math.pow(.95,Math.abs(r*.05)),a=r>0?1/Math.abs(o):o;i.zoom=Math.max(d,Math.min(h,i.zoom*a*v)),i.updateProjectionMatrix()}else{this._updateZoomDirection();const o=y.copy(e);if(this.zoomPointSet||this._updateZoomPoint()){const a=t.distanceTo(i.position);if(r<0){const m=Math.min(0,a-n);r=r*a*v*.0025,r=Math.max(r,m)}else{const m=Math.max(0,a-s);r=r*Math.max(a-s,0)*v*.0025,r=Math.min(r,m)}i.position.addScaledVector(e,r),i.updateMatrixWorld()}else{const a=this._getPointBelowCamera();if(a){const m=a.distance;o.set(0,0,-1).transformDirection(i.matrixWorld),i.position.addScaledVector(o,r*m*.01),i.updateMatrixWorld()}}}}_updateZoomDirection(){if(this.zoomDirectionSet)return;const{domElement:t,raycaster:e,camera:i,zoomDirection:s,pointerTracker:n}=this;n.getLatestPoint(u),R(u.x,u.y,t,H),W(e,H,i),s.copy(e.ray.direction).normalize(),this.zoomDirectionSet=!0}_updateZoomPoint(){const{camera:t,zoomDirectionSet:e,zoomDirection:i,raycaster:s,zoomPoint:n,pointerTracker:c,domElement:p}=this;if(this._zoomPointWasSet=!1,!e)return!1;t.isOrthographicCamera&&c.getLatestPoint(L)?(R(L.x,L.y,p,L),W(s,L,t)):(s.ray.origin.copy(t.position),s.ray.direction.copy(i),s.near=0,s.far=1/0);const d=this._raycast(s);return d?(n.copy(d.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0):!1}_getPointBelowCamera(t=this.camera.position,e=this.up){const{raycaster:i}=this;i.ray.direction.copy(e).multiplyScalar(-1),i.ray.origin.copy(t).addScaledVector(e,1e5),i.near=0,i.far=1/0;const s=this._raycast(i);return s&&(s.distance-=1e5),s}_updatePosition(t){const{raycaster:e,camera:i,pivotPoint:s,up:n,pointerTracker:c,domElement:p,state:d,dragInertia:h,enableDamping:v}=this;if(d===E){if(c.getCenterPoint(u),R(u.x,u.y,p,u),J.setFromNormalAndCoplanarPoint(n,s),W(e,u,i),Math.abs(e.ray.direction.dot(n))<F){const r=Math.acos(F);z.crossVectors(e.ray.direction,n).normalize(),e.ray.direction.copy(n).applyAxisAngle(z,r).multiplyScalar(-1)}if(this.getUpDirection(s,f),Math.abs(e.ray.direction.dot(f))<Z){const r=Math.acos(Z);z.crossVectors(e.ray.direction,f).normalize(),e.ray.direction.copy(f).applyAxisAngle(z,r).multiplyScalar(-1)}e.ray.intersectPlane(J,y)&&(I.subVectors(s,y),i.position.add(I),i.updateMatrixWorld(),I.multiplyScalar(1/t),c.getMoveDistance()/t<2*window.devicePixelRatio?h.lerp(I,.5):h.copy(I))}else v&&(i.position.addScaledVector(h,t),i.updateMatrixWorld())}_updateRotation(t){const{pivotPoint:e,pointerTracker:i,domElement:s,state:n,rotationInertia:c,enableDamping:p}=this;n===b?(i.getCenterPoint(u),i.getPreviousCenterPoint(K),T.subVectors(u,K).multiplyScalar(2*Math.PI/s.clientHeight),this._applyRotation(T.x,T.y,e),T.multiplyScalar(1/t),i.getMoveDistance()/t<2*window.devicePixelRatio?c.lerp(T,.5):c.copy(T)):p&&this._applyRotation(c.x*t,c.y*t,e)}_applyRotation(t,e,i){if(t===0&&e===0)return;const{camera:s,minAltitude:n,maxAltitude:c,rotationSpeed:p}=this,d=-t*p;let h=e*p;j.set(0,0,1).transformDirection(s.matrixWorld),this.getUpDirection(i,f),y.crossVectors(f,j).normalize(),X.set(1,0,0).transformDirection(s.matrixWorld).normalize();const r=Math.sign(y.dot(X))*f.angleTo(j);h>0?(h=Math.min(r-n-.01,h),h=Math.max(0,h)):(h=Math.max(r-c,h),h=Math.min(0,h)),M.setFromAxisAngle(f,d),A(i,M,D),s.matrixWorld.premultiply(D),z.set(-1,0,0).transformDirection(s.matrixWorld),M.setFromAxisAngle(z,h),A(i,M,D),s.matrixWorld.premultiply(D),s.matrixWorld.decompose(s.position,s.quaternion,y)}_setFrame(t,e){const{up:i,camera:s,state:n,zoomPoint:c,zoomDirectionSet:p,zoomPointSet:d,reorientOnDrag:h,scaleZoomOrientationAtEdges:v}=this;s.updateMatrixWorld(),M.setFromUnitVectors(i,t);const r=n;if(p&&(d||this._updateZoomPoint())){if(this.getUpDirection(c,y),v){let o=Math.max(y.dot(i)-.6,0)/.4;o=mt.mapLinear(o,0,.5,0,1),o=Math.min(o,1),s.isOrthographicCamera&&(o*=.1),M.slerp(St,1-o)}A(c,M,D),s.matrixWorld.premultiply(D),s.matrixWorld.decompose(s.position,s.quaternion,y),this.zoomDirectionSet=!1,this._updateZoomDirection()}else r===E&&h&&e&&(A(e,M,D),s.matrixWorld.premultiply(D),s.matrixWorld.decompose(s.position,s.quaternion,y));i.copy(t),s.updateMatrixWorld()}_raycast(t){const{scene:e,useFallbackPlane:i,fallbackPlane:s}=this,n=t.intersectObject(e)[0]||null;if(n)return n;if(i){const c=s;if(t.ray.intersectPlane(c,y))return{point:y.clone(),distance:t.ray.origin.distanceTo(y)}}return null}}export{E as D,xt as E,_ as N,R as a,Mt as b,Dt as c,A as m,W as s};
