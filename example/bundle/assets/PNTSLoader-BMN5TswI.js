import{r as h,F as y,B as C}from"./readMagicBytes-Da5ueiou.js";import{L as U}from"./LoaderBase-CVSPpjX2.js";import{bc as w,af as G,k as P,ah as R,ai as _,C as m,br as V}from"./three.module-DpclfMcJ.js";class x extends U{parse(s){const t=new DataView(s),o=h(t);console.assert(o==="pnts");const g=t.getUint32(4,!0);console.assert(g===1);const n=t.getUint32(8,!0);console.assert(n===s.byteLength);const c=t.getUint32(12,!0),l=t.getUint32(16,!0),a=t.getUint32(20,!0),O=t.getUint32(24,!0),T=28,e=s.slice(T,T+c+l),u=new y(e,0,c,l),i=T+c+l,f=s.slice(i,i+a+O),b=new C(f,u.getData("BATCH_LENGTH")||u.getData("POINTS_LENGTH"),0,a,O);return Promise.resolve({version:g,featureTable:u,batchTable:b})}}function M(L){const s=L>>11,t=L>>5&63,o=L&31,g=Math.round(s/31*255),n=Math.round(t/63*255),c=Math.round(o/31*255);return[g,n,c]}const D={RGB:"color",POSITION:"position"};class Q extends x{constructor(s=w){super(),this.manager=s}parse(s){return super.parse(s).then(async t=>{const{featureTable:o,batchTable:g}=t,n=new G,c=o.header.extensions,l=new P;let a;if(c&&c["3DTILES_draco_point_compression"]){const{byteOffset:e,byteLength:u,properties:i}=c["3DTILES_draco_point_compression"],f=this.manager.getHandler("draco.drc");if(f==null)throw new Error("PNTSLoader: dracoLoader not available.");const b={};for(const p in i)if(p in D&&p in i){const S=D[p];b[S]=i[p]}const N={attributeIDs:b,attributeTypes:{position:"Float32Array",color:"Uint8Array"},useUniqueIDs:!0},B=o.getBuffer(e,u);a=await f.decodeGeometry(B,N),a.attributes.color&&(n.vertexColors=!0)}else{const e=o.getData("POINTS_LENGTH"),u=o.getData("POSITION",e,"FLOAT","VEC3"),i=o.getData("RGB",e,"UNSIGNED_BYTE","VEC3"),f=o.getData("RGBA",e,"UNSIGNED_BYTE","VEC4"),b=o.getData("RGB565",e,"UNSIGNED_SHORT","SCALAR"),N=o.getData("CONSTANT_RGBA",e,"UNSIGNED_BYTE","VEC4"),B=o.getData("POSITION_QUANTIZED",e,"UNSIGNED_SHORT","VEC3"),p=o.getData("QUANTIZED_VOLUME_SCALE",e,"FLOAT","VEC3"),S=o.getData("QUANTIZED_VOLUME_OFFSET",e,"FLOAT","VEC3");if(a=new R,B){const E=new Float32Array(e*3);for(let r=0;r<e;r++)for(let A=0;A<3;A++){const d=3*r+A;E[d]=B[d]/65535*p[A]}l.x=S[0],l.y=S[1],l.z=S[2],a.setAttribute("position",new _(E,3,!1))}else a.setAttribute("position",new _(u,3,!1));if(f!==null)a.setAttribute("color",new _(f,4,!0)),n.vertexColors=!0,n.transparent=!0,n.depthWrite=!1;else if(i!==null)a.setAttribute("color",new _(i,3,!0)),n.vertexColors=!0;else if(b!==null){const E=new Uint8Array(e*3);for(let r=0;r<e;r++){const A=M(b[r]);for(let d=0;d<3;d++){const I=3*r+d;E[I]=A[d]}}a.setAttribute("color",new _(E,3,!0)),n.vertexColors=!0}else if(N!==null){const E=new m(N[0],N[1],N[2]);n.color=E;const r=N[3]/255;r<1&&(n.opacity=r,n.transparent=!0,n.depthWrite=!1)}}["BATCH_LENGTH","NORMAL","NORMAL_OCT16P"].forEach(e=>{e in o.header&&console.warn(`PNTSLoader: Unsupported FeatureTable feature "${e}" detected.`)});const O=new V(a,n);O.position.copy(l),t.scene=O,t.scene.featureTable=o,t.scene.batchTable=g;const T=o.getData("RTC_CENTER");return T&&(t.scene.position.x+=T[0],t.scene.position.y+=T[1],t.scene.position.z+=T[2]),t})}}export{Q as P};
